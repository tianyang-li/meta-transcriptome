Index: correctedGraph.h
===================================================================
--- correctedGraph.h	(revision 457)
+++ correctedGraph.h	(working copy)
@@ -27,6 +27,14 @@
 
 void correctGraph(Graph * graph, IDnum * sequenceLengths, Category * sequenceCategories);
 
+// Clumsy and dirty patch
+boolean *removeLowCoverageNodesAndDenounceDubiousReadsConserveLong(Graph * graph,
+						       double minCov,
+						       ReadSet * reads,
+						       boolean export,
+						       Coordinate minLength,
+						       char *filename);
+
 // Black arts:
 void setMaxReadLength(int value);
 void setMaxGaps(int value);
Index: oases.c
===================================================================
--- oases.c	(revision 457)
+++ oases.c	(working copy)
@@ -67,6 +67,7 @@
 	puts("\t-min_pair_count <integer>\t: minimum number of paired end connections to justify the scaffolding of two long contigs (default: 4)");
 	puts("\t-min_trans_lgth <integer>\t: Minimum length of output transcripts (default: hash-length)");
 	puts("\t-paired_cutoff <floating-point>\t: minimum ratio allowed between the numbers of observed and estimated connecting read pairs");
+	puts("\t-conserveLong <yes|no>\t\t:Preserve contigs mapping onto long sequences to be preserved from coverage cutoff (default: no)");
 	puts("\t\tMust be part of the open interval ]0,1[ (default: 0.1)");
 	puts("\t-scaffolding <yes|no>\t\t:Allow gaps in transcripts (default: yes)");
 	puts("\t-degree_cutoff <integer>\t: Maximum allowed degree on either end of a contigg to consider it 'unique' (default: 3)");
@@ -103,6 +104,7 @@
 	boolean unusedReads = false;
 	boolean exportAssembly = false;
 	boolean scaffolding = true;
+	boolean conserveLong = false;
 	boolean exportAlignments = false;
 
 	setProgramName("oases");
@@ -170,6 +172,9 @@
 		} else if (strcmp(arg, "-scaffolding") == 0) {
 			scaffolding =
 			    (strcmp(argv[arg_index], "yes") == 0);
+		} else if (strcmp(arg, "-conserveLong") == 0) {
+			conserveLong =
+			    (strcmp(argv[arg_index], "yes") == 0);
 		} else if (strcmp(arg, "-min_pair_count") == 0) {
 			sscanf(argv[arg_index], "%i", &arg_int);
 			setUnreliableConnectionCutoff_oases(arg_int);
@@ -261,17 +266,28 @@
 	sequenceLengths =
 	    getSequenceLengths(reads, getWordLength(graph));
 
-	dubious =
-	    removeLowCoverageNodesAndDenounceDubiousReads(graph,
-							  coverageCutoff,
-							  reads,
-							  false,
-							  0,
-							  "nothing");
+	if (!conserveLong)
+	    dubious =
+		removeLowCoverageNodesAndDenounceDubiousReads(graph,
+							      coverageCutoff,
+							      reads,
+							      false,
+							      0,
+							      "nothing");
+	else 
+	    dubious =
+		removeLowCoverageNodesAndDenounceDubiousReadsConserveLong(graph,
+							      coverageCutoff,
+							      reads,
+							      false,
+							      0,
+							      "nothing");
 	clipTipsHard(graph);
 
 	correctGraph(graph, sequenceLengths, reads->categories);
 
+	//exportLongNodeSequences("toto.fa", graph, 50);
+
 	// Set insert lengths and their standard deviations
 	createReadPairingArray(reads);
 	for (cat = 0; cat < CATEGORIES; cat++) {
Index: correctedGraph.c
===================================================================
--- correctedGraph.c	(revision 457)
+++ correctedGraph.c	(working copy)
@@ -2568,3 +2568,170 @@
 	}
 	MAXDIVERGENCE = value;
 }
+
+// 
+// What follows is a very ugly patch which will have to be normalized with the Velvet API
+// My sincere apologies
+//
+static Coordinate getTotalCoverage(Node * node)
+{
+	Category cat;
+	Coordinate coverage = 0;
+
+	for (cat = 0; cat < CATEGORIES; cat++)
+		coverage += getVirtualCoverage(node, cat);
+
+	return coverage;
+}
+
+static void exportLongNodeSequence(FILE * outfile, Node * node, Graph * graph) {
+	TightString *tString;
+	Coordinate position;
+	char nucleotide;
+	int WORDLENGTH = getWordLength(graph);
+	GapMarker *gap;
+	IDnum nodeIndex = getNodeID(node);
+
+	tString = expandNode(node, WORDLENGTH);
+	velvetFprintf(outfile, ">NODE_%ld_length_%lld_cov_%f\n",
+		(long) nodeIndex, (long long) getNodeLength(node),
+		(getVirtualCoverage(node, 0)
+		 + getVirtualCoverage(node, 1)
+		 + readCoverage(node)) /
+		(float) getNodeLength(node));
+
+	gap = getGap(node, graph);
+	for (position = 0; position < WORDLENGTH; position++) {
+		if (position % 60 == 0 && position > 0)
+			velvetFprintf(outfile, "\n"); 
+		if (gap && position >= getGapFinish(gap))
+			gap = getNextGap(gap);
+
+		if (gap == NULL || position < getGapStart(gap)) {
+			nucleotide =
+			    getNucleotideChar(position, tString);
+			velvetFprintf(outfile, "%c", nucleotide);
+		} else
+			velvetFprintf(outfile, "N");
+	}
+
+	gap = getGap(node, graph);
+	for (; position < getLength(tString); position++) {
+		if (position % 60 == 0)
+			velvetFprintf(outfile, "\n");
+
+		if (gap
+		    && position - WORDLENGTH + 1 >=
+		    getGapFinish(gap))
+			gap = getNextGap(gap);
+
+		if (gap == NULL
+		    || position - WORDLENGTH + 1 <
+		    getGapStart(gap)) {
+			nucleotide =
+			    getNucleotideChar(position, tString);
+			velvetFprintf(outfile, "%c", nucleotide);
+		} else
+			velvetFprintf(outfile, "N");
+	}
+	velvetFprintf(outfile, "\n");
+	destroyTightString (tString);
+}
+
+
+boolean *removeLowCoverageNodesAndDenounceDubiousReadsConserveLong(Graph * graph,
+						       double minCov,
+						       ReadSet * reads,
+						       boolean export,
+						       Coordinate minLength,
+						       char *filename)
+{
+	IDnum index;
+	Node *node;
+	boolean denounceReads = readStartsAreActivated(graph);
+	boolean *res = NULL; 
+	ShortReadMarker *nodeArray, *shortMarker;
+	PassageMarkerI marker;
+	IDnum maxIndex;
+	IDnum readID;
+	IDnum index2;
+	FILE * outfile = NULL;
+
+	velvetLog("Removing contigs with coverage < %f...\n", minCov);
+		
+	if (denounceReads)
+		res = callocOrExit(sequenceCount(graph), boolean);
+		
+	if (export) {
+		outfile = fopen(filename, "w");
+
+		if (outfile == NULL) {
+			velvetLog("Could not write into %s, sorry\n", filename);
+			return res;
+		} else {
+			velvetLog("Writing contigs into %s...\n", filename);
+		}
+	}
+
+
+	for (index = 1; index <= nodeCount(graph); index++) {
+		node = getNodeInGraph(graph, index);
+
+		if (getNodeLength(node) == 0)
+			continue;
+
+		if (getTotalCoverage(node) / getNodeLength(node) < minCov 
+		    && getMarker(node) == NULL_IDX) {
+			if (denounceReads) {
+				nodeArray = getNodeReads(node, graph);
+				maxIndex = getNodeReadCount(node, graph);
+				for (index2 = 0; index2 < maxIndex; index2++) {
+					shortMarker =
+					    getShortReadMarkerAtIndex(nodeArray,
+								      index2);
+					readID = getShortReadMarkerID(shortMarker);
+					//velvetLog("Dubious %d\n", readID);
+					if (readID > 0)
+						res[readID - 1] = true;
+					else
+						res[-readID - 1] = true;
+				}
+
+				nodeArray = getNodeReads(getTwinNode(node), graph);
+				maxIndex =
+				    getNodeReadCount(getTwinNode(node), graph);
+				for (index2 = 0; index2 < maxIndex; index2++) {
+					shortMarker =
+					    getShortReadMarkerAtIndex(nodeArray,
+								      index2);
+					readID = getShortReadMarkerID(shortMarker);
+					//velvetLog("Dubious %d\n", readID);
+					if (readID > 0)
+						res[readID - 1] = true;
+					else
+						res[-readID - 1] = true;
+				}
+			}
+
+			while ((marker = getMarker(node))) {
+				if (!isInitial(marker)
+				    && !isTerminal(marker))
+					disconnectNextPassageMarker
+					    (getPreviousInSequence(marker),
+					     graph);
+				destroyPassageMarker(marker);
+			}
+
+			if (export && getNodeLength(node) > minLength) 
+				exportLongNodeSequence(outfile, node, graph);
+
+			destroyNode(node, graph);
+		}
+	}
+
+	if (export)
+		fclose(outfile);
+
+	concatenateGraph(graph);
+	return res;
+}
